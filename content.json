{"pages":[],"posts":[{"title":"iOS进阶-GCD","text":"Grand Central Dispatch（GCD），可理解为多线程中央调度器What’s GCD?GCD是苹果开发的一个多核编程的解决方法，首次在MacOS X10.6推出使用，随后引用到iOS4.0中。 GCD使用过程中的优势：较NSThread、NSOperationQueue、NSInvocationOperation等技术使用更加方便在实际开发中，使用GCD方法可以达到相同的效果下精简代码，比如可以减少一些方法的定义和方法相互传递之间的变量封装，且项目的逻辑异常清晰。 GCD的特性：1、GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程），你只需告诉它要做什么，比如说单次执行，延迟执行……等等，GCD就会自动执行，瓦全不需要你去管理线程相关的事情。GCD是基于纯C语言的多线程管理方案，使用者无需过多参与线程的管理，只需要将想要执行的代码，添加到想要添加的调度队列即可。2、GCD会自动利用更多的CPU内核（比如双核、四核），它存在于libdispatch.dylib这个库中，这是程序动态加载的库类，不需要个人动手导入。3 、GCD可用于多核的并行运算。 GCD的使用：有两个核心概念：任务和队列 任务：执行操作，放在block中 任务的两种执行方式：同步执行（sync）和异步执行（async） 同步执行：dispatch_sync(dispatch_queue_t queue,dispatch_block_t block);异步执行：dispatch_async(dispatch_queue_t queue),dispatch_block_t block);#### 同步和异步的区别：同步：在当前线程中执行任务，会发生堵塞，不具备开启新线程的能力。异步：在另外一条线程中执行，在新的线程中执行任务，具备开启新线程的能力。在代码中的区别就只相差了一个字母。#### block的定义类似于指针的定义，用“^”代替了函数指针的“*”符号，指的是以插入“^”为开头标识符的代码块。可使程序块在代码中以内嵌的方式定义，且可以访问在创建它的范围内的可用的变量。—## GCD的使用步骤：1、创建一个队列（串行队列或并发队列） 串行队列：只开启一个线程，任务一个接一个地执行 并发队列：开启多个队列，并且同时执行任务2、将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行创建方法dispatch_sync或异步执行创建方法dispatch_async）### 队列(Dispatch Queue):执行等待的队列，用来存放任务的队列，采用FIFO(先进先出)的原则，每读取一个任务，队列中释放一个任务。 六种常规的队列与任务执行组合方式：1、同步执行+并发队列2、异步执行+并发队列3、同步执行+串行队列4、异步执行+串行队列5、同步执行+主队列6、异步执行+主队列 系统提供的dispatch方法1.后台执行Dispatch_async(dispatch_get_global_queue(0,0), ^{ //something });2.主线程执行Dispatch_async(dispatch_get_main_queue(0,0), ^{ //something });3.一次性执行static dispatch_once_t onceToken; Dispatch_once(&amp;onceToken, ^{ //code to be executed });4.延迟2秒执行double delayInseconds = 2.0; Dispatch_time_t poopTime = dispatch_time(DISPATCH_TIME_NOW,delayInseconds *NSEC_PER_SEC); Dispatch_after(popTime,dispatch_get_main_queue(), ^(void){ //code to be executed on the main queue after delay }); Dispatch_queue_t可自己定义，用 dispatch_queue_create方法例如：dispatch_queue_t urls_queue = dispatch_queue_create(“blog.devtang.com”,NULL); GCD的高级用法使用GCD队列组：dispatch_group异步执行的队列：dispatch_group_async监听group中任务完成的状态：dispatch_group_notify阻塞当前线程，当group任务完成后继续执行：dispatch_group_wait例如：dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group,dispatch_get_global_queue(0,0), ^{ // 并行执行的线程一 }); dispatch_group_async(group,dispatch_get_global_queue(0,0), ^{ // 并行执行的线程二 }); dispatch_group_notify(group,dispatch_get_global_queue(0,0), ^{ //汇总结果 }); GCD线程间的通信在iOS开发中，我们常把点击、滚动、拖拽等UI刷新事件放在主线程中，把耗时的图片下载、文件上传操作放在其他线程里，当其他线程完成了耗时操作，需要回到主线程，这就是线程之间的通信。","link":"/2020/10/07/GCD/"},{"title":"Markdown语法总结","text":"markdown语法实例 强调 分割线 引用 标题Setext方式 大标题 小标题 标题Atx方式 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 无序列表 有序列表 嵌套列表 文字超链Inline方式 图片超链 索引超链Reference方式 自动链接 代码行内代码 代码段落代码 注释 转义字符 表格 其他 段落缩进空格 字体字号颜色 标签 1 强调 星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格 一个人来到田纳西 毫无疑问 *我做的馅饼 是全天下* 最好吃的 1 2 3 4 5 6 7 一个人来到田纳西 毫无疑问 *我做的馅饼 是全天下* 最好吃的 2 分割线 三个或更多-_*，必须单独一行，可含空格 -– 1 2 3 3 引用 翻译成html就是 ，符号后的空格可不要 > 引用 1 引用 内层符号前的空格必须要 >引用 >&gt;引用中的引用 1 2 引用 引用中的引用 4 标题：Setext方式 三个或更多 大标题 === 小标题 -– 1 2 3 4 大标题 小标题 5 标题：Atx方式 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 1 2 3 4 5 6 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 6 无序列表 符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长 - 无序列表 - 无序列表 - 无序列表 - 无序列表：我很长。我也很长！那比一比啊 1 2 3 4 无序列表 无序列表 无序列表 无序列表：我很长。我也很长！那比一比啊 符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表 * 无序列表 * 无序列表 * 无序列表 * 无序列表：我很长。我也很长！那比一比啊 1 2 3 4 无序列表 无序列表 无序列表 无序列表：我很长。我也很长！那比一比啊 7 有序列表 数字不能省略但可无序，点号之后的空格不能少 \\1. 有序列表 \\2. 有序列表 \\3. 有序列表 \\8. 有序列表 1 2 3 4 有序列表 有序列表 有序列表 有序列表 嵌套列表 -+*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少 - 嵌套列表1 + 嵌套列表2 + 嵌套列表3 - 嵌套列表4 * 嵌套列表5 - 嵌套列表6 1 2 3 4 5 6 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 嵌套列表5 嵌套列表6 8 文字超链：Inline方式 Tooltips可省略 不如 1 不如 图片超链 多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记 1 9 索引超链：Reference方式 索引，1 可以是任意字符 不如 1 2 不如 10 自动链接 尖括号 http://ibruce.info bu.ru@qq.com 1 2 http://ibruce.info bu.ru@qq.com 11 代码：行内代码 在第一行后指定编程语言，也可以不指定 \\12345678910111213141516171819202122@requires_authorizationdef somefunc(param1='', param2=0):​ '''A docstring'''​ if param1 &gt; param2: # interesting​ print 'Greater'​ return (param2 - param1 + 1) or Noneclass SomeClass:​ pass\\&gt;&gt;&gt; message = '''interpreter... prompt'''\\ 1 2 3 4 5 6 7 8 9 10 11 12 可代码高亮 1 @requires_authorization def somefunc(param1=’’, param2=0): ​ ‘’’A docstring’’’ ​ if param1 &gt; param2: # interesting ​ print ‘Greater’ ​ return (param2 - param1 + 1) or None class SomeClass: ​ pass >&gt;&gt; message = ‘’’interpreter … prompt’’’ 1 2 3 4 5 6 7 8 9 10 12 代码：段落代码 每行文字前加4个空格或者1个Tab ​ val s = “hello Markdown” ​ println( s ) ​ val s = “hello Markdown” ​ println( s ) 1 2 3 4 val s = “hello Markdown” println( s ) val s = “hello Markdown” println( s ) 1 2 3 4 13 注释 用html的注释，好像只有这样？ 1 14 转义字符 用html的注释，好像只有这样？ Markdown中的转义字符为\\，转义的有： \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 15 表格 | Tables | Are | Cool | | ————- |:————-:| —–:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 1 2 3 4 5 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 或者 项目 | 价格 ——– | — Computer | $1600 Phone | $12 Pipe | $1 1 2 3 4 5 项目 价格 Computer $1600 Phone $12 Pipe $1 16 其他 段落缩进（空格） 半方大的空白&ensp;或 看，飞碟 全方大的空白&emsp;或 看，飞碟 不断行的空白格&nbsp;或 看，飞碟 &emsp;&emsp;段落从此开始。 1 2 3 4 半方大的空白 或 看，飞碟 全方大的空白 或 看，飞碟 不断行的空白格 或 看，飞碟 段落从此开始。 字体、字号、颜色 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 1 2 3 4 5 6 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 标签 行内标签` -——————–","link":"/2018/11/19/title/"},{"title":"像我这样的人","text":"像我这样聪明的人 早就告别了单纯 怎么还是用了一段情 去换一身伤痕 像我这样懦弱的人 凡事都要留几分 怎么曾经也会为了谁 想过奋不顾身 像我这样孤单的人 像我这样傻的人 像我这样不甘平凡的人 你还见过多少人 像我这样莫名其妙的人会不会有人心疼","link":"/2018/11/19/像我这样的人/"},{"title":"Swift学习第一周","text":"Swift定义：Swift 是一种新的编程语言，用于编写 iOS 和 macOS 应用。Swift 结合了 C 和 Objective-C 的优点并且不受C兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，他的降临将重新定义软件开发。 Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa的基础上构建框架栈并将其标准化。Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。 Objective-C 开发者对 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性并且支持过程式编程和面向对象编程。 语言优势：Swift 将现代编程语言的精华和苹果工程师文化的智慧结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。Swift 既可以用于开发“hello, world”这样的小程序，也可以用于开发一套完整的操作系统。所有的这些特性让 Swift 对于开发者和苹果来说都是一项值得的投资。 Swift是编程语言的最新研究成果，并结合数十年的经验建设苹果平台的结果。结转自Objective-C的命名参数表示在一个干净的语法，使得Swift的API更容易阅读和维护。 推断类型使代码更干净，不易犯错误，而模块消除了头，并提供命名空间。内存自动管理，而你甚至都不需要输入分号。 初学：1、 • 简单值(Simple Values) 2、 • 控制流(Control Flow) 3、 • 函数和闭包(Functions and Closures) 4、 • 对象和类(Objects and Classes) 5、 • 枚举和结构体(Enumerations and Structures) 6、 • 协议和扩展(Protocols and Extensions) 7、 • 错误处理(Error Handling) 8、 • 泛型(Generics) 简单值 使用 let 来声明常量，使用 var 来声明变量 12345var Number = 1let Constant = 7let appleSummary = \"I have a dream.\" 使用方括号 [] 来创建数组和字典，并使用下标或者键(key)来访问元素。最后一个元素后面允许有个逗号 1234567var shoppingLists = [\"99.9RMB\",\"52.1RMB\",\"13.14RMB\"]shoppingLists[1] = \"clothes\"shoppingLists[2] = \"bags\"shoppingList[3] = \"shoes\" 创建一个空数组或者字典，使用初始化语法 12let emptyArray = [String]()let emptyDictionary = [String: Float]() 对象和类 使用 class 和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样 12345class Shape { var numberOfSides = 0 func simpleDescription() -&gt; String { return \"A shape with \\(numberOfSides) sides.\" } 要创建一个类的实例，在类名后面加上括号 123var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription() 构造函数来初始化类实例,使用 init 来创建一个构造器 12345class NamedShape { var numberOfSides: Int = 0 var name: String init(name: String) { self.name = name } 12func simpleDescription() -&gt; String { return \"A shape with \\(numberOfSides) sides.\" :self 被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明(就像 numberOfSides )还是通过构造器(就像 name )。 控制流 使用 if 和 switch 来进行条件操作，使用 for-in 、 for 、 while 和 repeat-while 来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的 1234567let individualScores = [75, 43, 103, 87, 12]var teamScore = 0for score in individualScores { if score &gt; 50 { teamScore += 3 } else { teamScore += 1 } } 1print(teamScore) 可以一起使用 if 和 let 来处理值缺失的情况 switch 支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等 1234567891011let vegetable = \"red pepper\"switch vegetable {case \"celery\": print(\"Add some raisins and make ants on a log.\")case \"cucumber\", \"watercress\": print(\"That would make a good tea sandwich.\")case let x where x.hasSuffix(\"pepper\"): print(\"Is it a spicy \\(x)?\")default: print(\"Everything tastes good in soup.\")} for-in 来遍历字典，需要两个变量来表示每个键值对。字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束 1234567891011let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibonacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25],]var largest = 0for (kind, numbers) in interestingNumbers { for number in numbers { if number &gt; largest { largest = number } 使用 while 来重复运行一段代码直到不满足条件。循环条件也可以在结尾，保证能至少循环一次 1234567 var n = 2 while n &lt; 100 {n=n* 2 } print(n) var m = 2 repeat {m=m* 2 } while m 100 print(m) 使用 ..&lt; 创建的范围不包含上界，如果想包含的话需要使用 … 函数和闭包 使用 func 来声明一个函数，使用名字和参数来调用函数。使用 -&gt; 来指定函数返回值的类型 1234func greet(name: String, day: String) -&gt; String { return \"Hello \\(name), today is \\(day).\"}greet(\"Bob\", day: \"Tuesday\") 元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示 12345678910111213func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) { var min = scores[0] var max = scores[0] var sum = 0 for score in scores { if score &gt; max { max = score } else if score &lt; min {min = score } sum += score } return (min, max, sum)}let statistics = calculateStatistics([5, 3, 100, 3, 9])print(statistics.sum)print(statistics.2) Tips: 1、 函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式 ​ 2、 函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数 ​ 3、 有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。 ​ 4、你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号 函数也可以当做参数传入另一个函数 123456789101112func hasAnyMatches(list: [Int], condition: Int -&gt; Bool) -&gt; Bool { for item in list { if condition(item) { return true} } return false } func lessThanTen(number: Int) -&gt; Bool { return number &lt; 10 } var numbers = [20, 19, 7, 12] hasAnyMatches(numbers, condition: lessThanTen) 实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用 {} 来创建一个匿名闭包。使用 in 将参数和返回值类型声明与闭包函数体进行分离。 12345numbers.map({ (number: Int) -&gt; Int in let result = 3 * number return result })","link":"/2018/12/02/Swift学习第一周/"},{"title":"Git语法总结","text":"一、 Git命令用法 【1】 对Git的初步认识1. Git的定义Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git的功能特性从一般的开发者角度来看，git有以下的功能： 从服务器上克隆完整的Git仓库//repository（包括代码和版本信息）到单机上。 在自己的机器上根据不同的开发目的，创建分支，修改代码。 在单机上自己创建的分支上提交代码。 在单机上合并分支。 把服务器上最新的代码fetch下来，然后和自己的主分支合并。 生成补丁（patch），把补丁发送给主开发者。 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就直接通过。 一般开发者之间解决冲突的方法，开发者之间可以使用pull命令解决冲突，解决完冲突之后再向主开发者提交补丁。 从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能： 查看邮件或者通过其他方式查看一般开发者的提交状态。 打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。 向公共服务器提交结果，然后通知所有开发人员。 2. Git的优缺点优点： 适合分布式开发，强调个体。 公共服务器压力和数据量都不会太大。 速度快、灵活。 任意两个开发者之间可以容易地解决冲突。 离线工作。 缺点： 资料少（中文资料寥寥无几）。 学习周期相对而言比较长。 不符合常规思维。 代码保密性差，一旦开发者把整个库clone下来，就可以完全公开所有代码和版本信息。 【2】 操作Git（以Mac已安装Git，未安装的请参照BlogHexo博客搭建、本地配置及部署到Github）1. 创建版本库 打开终端并输入 //-&gt;后面输入的即是命令行 $-&gt;mkdir learngit$-&gt;cd learngit$-&gt;pwd/nidexiaokeaiyishangxian(Users)/learngit pwd命令用于显示当前文件夹所在目录，这个仓库位于/Users/nidexiaokeaiyishangxian/learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库：$-&gt;git initInitialized empty Git repository in /nidexiaokeaiyishangxian/learngit/.git/瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 2. 把文件添加到版本库编写一个readme.text$-&gt;Git is a version control system$-&gt;Git is free software 然后自己把readme.text放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。第一步，用命令git add告诉Git，把文件添加到仓库：$-&gt;git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。第二步，用命令git commit(提交文件命令)告诉Git，把文件提交到仓库：$-&gt;git commit -m “wrote a readme file”执行以后终端会提示：1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 commit可以一次提交很多文件，所以你可以多次add不同的文件，例如:$-&gt;git add file1.txt$-&gt;git add file2.txt file3.txt $-&gt;git commit -m “add 3 files.”3. 时光机穿梭我之前提交了一个readme.txt文件，于是，现在继续修改readme.txt文件，改成如下内容： Git is a distributed version control system.Git is free software.现在，运行git status命令看看结果： $-&gt;git statusOn branch masterChanges not staged for commit:(use “git add …” to update what will be committed)(use “git checkout – …” to discard changes in working directory) modified: readme.txt no changes added to commit (use “git add” and/or “git commit -a”) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。若想查看实际的修改内容，用git diff这个命令看看： $-&gt;git diff readme.txtdiff –git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644— a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system.Git is free software.git diff命令顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： $-&gt;git add readme.txt同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $-&gt;git statusOn branch masterChanges to be committed:(use “git reset HEAD …” to unstage) modified: readme.txtgit status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $-&gt;git commit -m “add distributed”[master e475afc] add distributed1 file changed, 1 insertion(+), 1 deletion(-)提交后，我们再用git status命令看看仓库的当前状态： $-&gt;git statusOn branch masternothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。(1) 版本回退git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数： $-&gt;git log –pretty=oneline 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributed eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme filegit reset命令将当前版本append GPL回退到上一个版本add distributed： $ git reset –hard HEAD^HEAD is now at e475afc add distributed (2) 工作区和暂存区工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。(https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0—) (3) 撤销修改git checkout – file命令可以丢弃工作区的修改： $-&gt;git checkout – readme.txt命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令git checkout命令。(4) 删除文件 rm删除命令： $-&gt;rm test.txt这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： $-&gt;git statusOn branch masterChanges not staged for commit:(use “git add/rm …” to update what will be committed)(use “git checkout – …” to discard changes in working directory) deleted: test.txt no changes added to commit (use “git add” and/or “git commit -a”)现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： $-&gt;git rm test.txtrm ‘test.txt’ $-&gt;git commit -m “remove test.txt”[master d46f35e] remove test.txt1 file changed, 1 deletion(-)delete mode 100644 test.txt 现在，文件就从版本库中被删除了。4. 远程仓库(1) 添加远程库 在本地的learngit仓库下运行命令：$-&gt;cd /Users/nidexiaokeaiyishangxian/learngit在终端里将文件夹定位到本地的learngit仓库 $-&gt;git remote add origin git@github.com:BayCi/learngit.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。从现在起，只要本地作了提交，就可以通过命令： $-&gt;git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！（2） 从远程库克隆命令git clone克隆一个本地库： $-&gt;git clone https://github.com/BayCi/BayCi.github.ioCloning into ‘BayCi.github.io’…remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done.注意把Git库的地址换成你自己的，然后进入BayCi.github.io目录看看，已经有README.md文件了： $-&gt;cd BayCi.github.io$-&gt;ls README.md4. 分支管理 Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 创建与合并分支 在Git里，master分支为主分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。","link":"/2018/11/20/Git语法总结/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"}],"categories":[]}