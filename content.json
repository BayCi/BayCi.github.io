{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/11/19/hello-world/"},{"title":"Markdown语法总结","text":"markdown语法实例 强调 分割线 引用 标题Setext方式 大标题 小标题 标题Atx方式 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 无序列表 有序列表 嵌套列表 文字超链Inline方式 图片超链 索引超链Reference方式 自动链接 代码行内代码 代码段落代码 注释 转义字符 表格 其他 段落缩进空格 字体字号颜色 标签 1 强调 星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格 一个人来到田纳西 毫无疑问 *我做的馅饼 是全天下* 最好吃的 1 2 3 4 5 6 7 一个人来到田纳西 毫无疑问 *我做的馅饼 是全天下* 最好吃的 2 分割线 三个或更多-_*，必须单独一行，可含空格 -– 1 2 3 3 引用 翻译成html就是 ，符号后的空格可不要 > 引用 1 引用 内层符号前的空格必须要 >引用 >&gt;引用中的引用 1 2 引用 引用中的引用 4 标题：Setext方式 三个或更多 大标题 === 小标题 -– 1 2 3 4 大标题 小标题 5 标题：Atx方式 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 1 2 3 4 5 6 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 6 无序列表 符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长 - 无序列表 - 无序列表 - 无序列表 - 无序列表：我很长。我也很长！那比一比啊 1 2 3 4 无序列表 无序列表 无序列表 无序列表：我很长。我也很长！那比一比啊 符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表 * 无序列表 * 无序列表 * 无序列表 * 无序列表：我很长。我也很长！那比一比啊 1 2 3 4 无序列表 无序列表 无序列表 无序列表：我很长。我也很长！那比一比啊 7 有序列表 数字不能省略但可无序，点号之后的空格不能少 \\1. 有序列表 \\2. 有序列表 \\3. 有序列表 \\8. 有序列表 1 2 3 4 有序列表 有序列表 有序列表 有序列表 嵌套列表 -+*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少 - 嵌套列表1 + 嵌套列表2 + 嵌套列表3 - 嵌套列表4 * 嵌套列表5 - 嵌套列表6 1 2 3 4 5 6 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 嵌套列表5 嵌套列表6 8 文字超链：Inline方式 Tooltips可省略 不如 1 不如 图片超链 多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记 1 9 索引超链：Reference方式 索引，1 可以是任意字符 不如 1 2 不如 10 自动链接 尖括号 http://ibruce.info bu.ru@qq.com 1 2 http://ibruce.info bu.ru@qq.com 11 代码：行内代码 在第一行后指定编程语言，也可以不指定 \\12345678910111213141516171819202122@requires_authorizationdef somefunc(param1='', param2=0):​ '''A docstring'''​ if param1 &gt; param2: # interesting​ print 'Greater'​ return (param2 - param1 + 1) or Noneclass SomeClass:​ pass\\&gt;&gt;&gt; message = '''interpreter... prompt'''\\ 1 2 3 4 5 6 7 8 9 10 11 12 可代码高亮 1 @requires_authorization def somefunc(param1=’’, param2=0): ​ ‘’’A docstring’’’ ​ if param1 &gt; param2: # interesting ​ print ‘Greater’ ​ return (param2 - param1 + 1) or None class SomeClass: ​ pass >&gt;&gt; message = ‘’’interpreter … prompt’’’ 1 2 3 4 5 6 7 8 9 10 12 代码：段落代码 每行文字前加4个空格或者1个Tab ​ val s = “hello Markdown” ​ println( s ) ​ val s = “hello Markdown” ​ println( s ) 1 2 3 4 val s = “hello Markdown” println( s ) val s = “hello Markdown” println( s ) 1 2 3 4 13 注释 用html的注释，好像只有这样？ 1 14 转义字符 用html的注释，好像只有这样？ Markdown中的转义字符为\\，转义的有： \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 15 表格 | Tables | Are | Cool | | ————- |:————-:| —–:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 1 2 3 4 5 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 或者 项目 | 价格 ——– | — Computer | $1600 Phone | $12 Pipe | $1 1 2 3 4 5 项目 价格 Computer $1600 Phone $12 Pipe $1 16 其他 段落缩进（空格） 半方大的空白&ensp;或 看，飞碟 全方大的空白&emsp;或 看，飞碟 不断行的空白格&nbsp;或 看，飞碟 &emsp;&emsp;段落从此开始。 1 2 3 4 半方大的空白 或 看，飞碟 全方大的空白 或 看，飞碟 不断行的空白格 或 看，飞碟 段落从此开始。 字体、字号、颜色 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 1 2 3 4 5 6 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 标签 行内标签` -——————–","link":"/2018/11/19/title/"},{"title":"Git语法总结","text":"一、 Git命令用法 【1】 对Git的初步认识1. Git的定义Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git的功能特性从一般的开发者角度来看，git有以下的功能： 从服务器上克隆完整的Git仓库//repository（包括代码和版本信息）到单机上。 在自己的机器上根据不同的开发目的，创建分支，修改代码。 在单机上自己创建的分支上提交代码。 在单机上合并分支。 把服务器上最新的代码fetch下来，然后和自己的主分支合并。 生成补丁（patch），把补丁发送给主开发者。 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就直接通过。 一般开发者之间解决冲突的方法，开发者之间可以使用pull命令解决冲突，解决完冲突之后再向主开发者提交补丁。 从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能： 查看邮件或者通过其他方式查看一般开发者的提交状态。 打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。 向公共服务器提交结果，然后通知所有开发人员。 2. Git的优缺点优点： 适合分布式开发，强调个体。 公共服务器压力和数据量都不会太大。 速度快、灵活。 任意两个开发者之间可以容易地解决冲突。 离线工作。 缺点： 资料少（中文资料寥寥无几）。 学习周期相对而言比较长。 不符合常规思维。 代码保密性差，一旦开发者把整个库clone下来，就可以完全公开所有代码和版本信息。 【2】 操作Git（以Mac已安装Git，未安装的请参照BlogHexo博客搭建、本地配置及部署到Github）1. 创建版本库 打开终端并输入 //-&gt;后面输入的即是命令行 $-&gt;mkdir learngit$-&gt;cd learngit$-&gt;pwd/nidexiaokeaiyishangxian(Users)/learngit pwd命令用于显示当前文件夹所在目录，这个仓库位于/Users/nidexiaokeaiyishangxian/learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库：$-&gt;git initInitialized empty Git repository in /nidexiaokeaiyishangxian/learngit/.git/瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 2. 把文件添加到版本库编写一个readme.text$-&gt;Git is a version control system$-&gt;Git is free software 然后自己把readme.text放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。第一步，用命令git add告诉Git，把文件添加到仓库：$-&gt;git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。第二步，用命令git commit(提交文件命令)告诉Git，把文件提交到仓库：$-&gt;git commit -m “wrote a readme file”执行以后终端会提示：1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 commit可以一次提交很多文件，所以你可以多次add不同的文件，例如:$-&gt;git add file1.txt$-&gt;git add file2.txt file3.txt $-&gt;git commit -m “add 3 files.”3. 时光机穿梭我之前提交了一个readme.txt文件，于是，现在继续修改readme.txt文件，改成如下内容： Git is a distributed version control system.Git is free software.现在，运行git status命令看看结果： $-&gt;git statusOn branch masterChanges not staged for commit:(use “git add …” to update what will be committed)(use “git checkout – …” to discard changes in working directory) modified: readme.txt no changes added to commit (use “git add” and/or “git commit -a”) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。若想查看实际的修改内容，用git diff这个命令看看： $-&gt;git diff readme.txtdiff –git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644— a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system.Git is free software.git diff命令顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： $-&gt;git add readme.txt同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $-&gt;git statusOn branch masterChanges to be committed:(use “git reset HEAD …” to unstage) modified: readme.txtgit status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $-&gt;git commit -m “add distributed”[master e475afc] add distributed1 file changed, 1 insertion(+), 1 deletion(-)提交后，我们再用git status命令看看仓库的当前状态： $-&gt;git statusOn branch masternothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。(1) 版本回退git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数： $-&gt;git log –pretty=oneline 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributed eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme filegit reset命令将当前版本append GPL回退到上一个版本add distributed： $ git reset –hard HEAD^HEAD is now at e475afc add distributed (2) 工作区和暂存区工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。(https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0—) (3) 撤销修改git checkout – file命令可以丢弃工作区的修改： $-&gt;git checkout – readme.txt命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令git checkout命令。(4) 删除文件 rm删除命令： $-&gt;rm test.txt这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： $-&gt;git statusOn branch masterChanges not staged for commit:(use “git add/rm …” to update what will be committed)(use “git checkout – …” to discard changes in working directory) deleted: test.txt no changes added to commit (use “git add” and/or “git commit -a”)现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： $-&gt;git rm test.txtrm ‘test.txt’ $-&gt;git commit -m “remove test.txt”[master d46f35e] remove test.txt1 file changed, 1 deletion(-)delete mode 100644 test.txt 现在，文件就从版本库中被删除了。4. 远程仓库(1) 添加远程库 在本地的learngit仓库下运行命令：$-&gt;cd /Users/nidexiaokeaiyishangxian/learngit在终端里将文件夹定位到本地的learngit仓库 $-&gt;git remote add origin git@github.com:BayCi/learngit.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。从现在起，只要本地作了提交，就可以通过命令： $-&gt;git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！（2） 从远程库克隆命令git clone克隆一个本地库： $-&gt;git clone https://github.com/BayCi/BayCi.github.ioCloning into ‘BayCi.github.io’…remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done.注意把Git库的地址换成你自己的，然后进入BayCi.github.io目录看看，已经有README.md文件了： $-&gt;cd BayCi.github.io$-&gt;ls README.md4. 分支管理 Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 创建与合并分支 在Git里，master分支为主分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。","link":"/2018/11/20/Git语法总结/"}],"tags":[],"categories":[]}